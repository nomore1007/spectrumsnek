#!/usr/bin/env python3
"""
SpectrumSnek üêçüìª
Main menu system for selecting and running various radio-related tools.
"""

import sys
import os
import curses
import time
from typing import List, Dict, Any

# Add current directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

class ModuleInfo:
    """Information about a loadable module."""
    def __init__(self, name: str, description: str, module_path: str, run_function):
        self.name = name
        self.description = description
        self.module_path = module_path
        self.run_function = run_function

class RadioToolsLoader:
    """Main loader with menu system for radio tools."""

    def __init__(self):
        self.modules: List[ModuleInfo] = []
        self.selected_index = 0
        self.web_portal_enabled = True  # Global web portal toggle
        self.load_modules()

    def load_modules(self):
        """Load available modules from plugins directory."""
        plugins_dir = "plugins"
        system_tools = None

        # Load plugins dynamically
        if os.path.exists(plugins_dir):
            for item in os.listdir(plugins_dir):
                plugin_path = os.path.join(plugins_dir, item)
                if os.path.isdir(plugin_path) and not item.startswith('__'):
                    try:
                        # Import the plugin module
                        plugin_module = __import__(f"{plugins_dir}.{item}", fromlist=[item])
                        info = plugin_module.get_module_info()

                        if item == "system_tools":
                            # Save system_tools to add last
                            system_tools = ModuleInfo(
                                info["name"],
                                info["description"],
                                f"{plugins_dir}.{item}",
                                plugin_module.run
                            )
                        else:
                            self.modules.append(ModuleInfo(
                                info["name"],
                                info["description"],
                                f"{plugins_dir}.{item}",
                                plugin_module.run
                            ))
                    except ImportError:
                        # Plugin not available, skip silently
                        pass
                    except Exception:
                        # Other errors, skip silently
                        pass

        # Add system_tools last if found
        if system_tools:
            self.modules.append(system_tools)

        # Web portal toggle (special menu item)
        self.modules.append(ModuleInfo(
            f"Web Portal: {'ON' if self.web_portal_enabled else 'OFF'}",
            "Toggle web interfaces for all tools",
            "web_toggle",
            self.toggle_web_portal
        ))



    def toggle_web_portal(self):
        """Toggle web portal on/off."""
        self.web_portal_enabled = not self.web_portal_enabled
        print(f"Web portal {'enabled' if self.web_portal_enabled else 'disabled'} globally")
        print("This affects all tools that support web interfaces.")
        input("Press Enter to continue...")

        # Update the menu item name
        for module in self.modules:
            if module.module_path == "web_toggle":
                module.name = f"Web Portal: {'ON' if self.web_portal_enabled else 'OFF'}"
                break

    def draw_menu(self, stdscr):
        """Draw the main menu."""
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        # Fallback for narrow terminals
        if width < 40:
            width = 80  # Default fallback

        # Title
        title = "SpectrumSnek üêçüìª"
        stdscr.addstr(0, (width - len(title)) // 2, title, curses.A_BOLD)

        # Subtitle
        subtitle = "Choose your radio adventure!"
        stdscr.addstr(2, (width - len(subtitle)) // 2, subtitle)

        # Simple layout for all connections
        start_y = 4
        for i, module in enumerate(self.modules):
            y = start_y + i
            if y >= height:
                break

            # Module name with selection indicator
            if i == self.selected_index:
                stdscr.addstr(y, 2, f"> {module.name}", curses.A_REVERSE | curses.A_BOLD)
            else:
                stdscr.addstr(y, 2, f"  {module.name}")

        # Description of selected item at bottom
        if self.modules:
            selected = self.modules[self.selected_index]
            desc_y = height - 2
            desc = selected.description[:width-4]
            stdscr.addstr(desc_y, 2, f"Desc: {desc}", curses.A_DIM)

        # Instructions
        instructions = "‚Üë‚Üì navigate, Enter select, 'q' quit"
        stdscr.addstr(height - 1, (width - len(instructions)) // 2, instructions, curses.A_DIM)

        stdscr.refresh()

    def run_menu(self, stdscr):
        """Run the menu system."""
        curses.curs_set(0)  # Hide cursor
        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Web portal enabled
        stdscr.nodelay(True)  # Non-blocking input

        while True:
            self.draw_menu(stdscr)

            # Handle input
            try:
                key = stdscr.getch()

                if key == ord('q') or key == ord('Q'):
                    return None  # Quit
                elif key == curses.KEY_UP:
                    self.selected_index = max(0, self.selected_index - 1)
                elif key == curses.KEY_DOWN:
                    self.selected_index = min(len(self.modules) - 1, self.selected_index + 1)
                elif key == ord('\n') or key == ord('\r') or key == curses.KEY_ENTER:
                    return self.modules[self.selected_index]  # Selected module
                elif key == 27:  # ESC
                    return None  # Quit

                time.sleep(0.05)  # Small delay to prevent high CPU usage

            except KeyboardInterrupt:
                return None

    def run_selected_module(self, module: ModuleInfo):
        """Run the selected module."""
        print(f"\nStarting {module.name}...")
        print(f"Description: {module.description}")
        print("Press Ctrl+C to stop\n")

        try:
            # Restore terminal for module execution
            curses.endwin()
            module.run_function()
        except KeyboardInterrupt:
            print(f"\n{module.name} stopped by user")
        except Exception as e:
            print(f"Error running {module.name}: {e}")
        finally:
            print(f"\nReturned to Radio Tools Loader")

    def run(self):
        """Main run method."""
        print("Radio Tools Loader")
        print("=" * 20)

        if not check_dependencies():
            sys.exit(1)

        loader = RadioToolsLoader()

        if len(sys.argv) > 1:
            # Direct module execution
            module_name = sys.argv[1]

            if module_name == "rtl_scanner" or module_name == "scanner":
                print("Starting RTL-SDR Scanner directly...")
                try:
                    import rtl_scanner
                    rtl_scanner.run()
                except ImportError:
                    print("RTL-SDR scanner not available. Run setup.sh first.")
                    sys.exit(1)
            elif module_name == "adsb" or module_name == "adsb_tool":
                print("Starting ADS-B Aircraft Tracker directly...")
                try:
                    import adsb_tool
                    adsb_tool.run()
                except ImportError:
                    print("ADS-B tool not available. Run setup.sh first.")
                    sys.exit(1)
        else:
            print(f"Unknown module: {module_name}")
            print("Available modules: rtl_scanner, adsb_tool, demo")
            sys.exit(1)
    else:
        # Interactive menu
        try:
            loader.run()
        except KeyboardInterrupt:
            print("\nRadio Tools Loader stopped by user")
        except Exception as e:
            print(f"\nError in interactive menu: {e}")
            print("Try running with a different terminal or check TERM variable")
            sys.exit(1)

if __name__ == "__main__":
    main()